/*********************************************************
 *	ì—”ì§„íŒŒì¼ ë¡œë“œ í›„ Module ê°ì²´ê°€ ìƒì„±ë˜ë©°,
 *  Module ê°ì²´ë¥¼ í†µí•´ API í´ë˜ìŠ¤ì— ì ‘ê·¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 
 *	 - Module.postRun : ì—”ì§„íŒŒì¼ ë¡œë“œ í›„ ì‹¤í–‰í•  í•¨ìˆ˜ë¥¼ ì—°ê²°í•©ë‹ˆë‹¤.
 *	 - Module.canvas : ì§€ë„ë¥¼ í‘œì‹œí•  canvas ì—˜ë¦¬ë¨¼íŠ¸ë¥¼ ì—°ê²°í•©ë‹ˆë‹¤.
 *********************************************************/
 
var Module = {
	preRun: [],
    postRun: [init],
	canvas: (function() {
		
		var canvas = document.createElement('canvas');
		
		canvas.id = "canvas";
		canvas.width="calc(100%)";
		canvas.height="100%";
		
		canvas.style.position = "fixed";
		canvas.style.top = "0px";
		canvas.style.left = "0px";
		canvas.setAttribute('tabindex', '-1');
		
		canvas.getContext("application/wasm", {preserveDrawingBuffer: true});
		
		document.body.appendChild(canvas);
		
		canvas.addEventListener("webglcontextlost", function(e) { alert('WebGL context lost. You will need to reload the page.'); e.preventDefault(); }, false);
		
		return canvas;
		
	})()
};

/* ì—”ì§„ ë¡œë“œ í›„ ì‹¤í–‰í•  ì´ˆê¸°í™” í•¨ìˆ˜(Module.postRun) */
function init() {
	console.log('ğŸ§­ XDWorld init() ì‹¤í–‰ë¨')

	Module.SetProxy("http://www.xdmap.com:8080/Landscape/js/proxy.jsp?url=");
	Module.SetEncodingVWorldDEM(true);
	
	Module.initialize({
		container: document.getElementById("MapContainer"),
		terrain : {
			dem : {
				url : "http://xdworld.vworld.kr:8080",
				name : "dem",
				servername : "XDServer3d",
				encoding : true
			},
			image : {
				url : "http://xdworld.vworld.kr:8080",
				name : "tile_mo_HD",
				servername : "XDServer3d"
			},
		},
		worker : {
				path : "./XDWorldWorker.js",
				count : 3,
				use : true,
			},
		defaultKey : "DFG~EpIREQDmdJe1E9QpdBca#FBSDJFmdzHoe(fB4!e1E(JS1I=="
	});
	
	Module.SetMobileMode(2);
	
	initPage();
	
	Module.getViewCamera().moveLonLatAlt(127.886114, 36.140026, 150000, true);
	
	Module.getViewCamera().setTilt(50.0);
	
	Module.getOption().setTextureCapacityLimit(false);
	
	Module.getOption().setPickingCalculateType(1);

	window.setXDWorldReady?.(true)
}
/*********************** ì•„ë˜ë¶€í„° API í…ŒìŠ¤íŠ¸ ì˜ì—­ ì…ë‹ˆë‹¤ ********************************************/

var GLOBAL = {
	Layer : null,
	Pipe : null,
	totalArea : false,
	strShape : "sphere",
	selectindex : [],
	positions : [],
	values : [],
	statistic : null,
	tilePositions: Array.from({ length: 10 }, () => ({ positions: [], values: [] })),// 10ê°œ êµ¬ì—­ ì´ˆê¸°í™”
	clustersPoints: [], // í´ëŸ¬ìŠ¤í„°ë§
	clustersValues: [] // í´ëŸ¬ìŠ¤í„°ë§
};

function initPage() {

	initEvent(Module.canvas);	
	/*
	var layer = Module.getTileLayerList().createXDServerLayer({
		url : "https://xdworld.vworld.kr",
		servername : "XDServer3d",
		name : "facility_build",
		type : 9,
		minLevel : 0,
		maxLevel : 15
	});
	*/
	
	Module.setRemoveVertexMemory(false);
	
	// ì§€í˜• ë°‘ì— ë“¤ì–´ê°ˆ ìˆ˜ ìˆê²Œ
	var Camera = Module.getViewCamera();
	Camera.setPermitUnderGround(true);
	Camera.setLimitTilt(-88.0);
	Camera.setLimitAltitude(-1000.0);
	
	GLOBAL.statistic = Module.getStatistic();
}


function initEvent(_canvas) {
	
	var mainDiv = document.getElementById("DV_Main");
	mainDiv.onmouseover = function() {
		Module.XDIsMouseOverDiv(true);
		//console.log("Mouse Over");
	};
	mainDiv.onmouseout = function() {
		Module.XDIsMouseOverDiv(false);
		//console.log("Mouse Out");
	};
	
	_canvas.addEventListener("contextmenu", function(e){
		e.preventDefault();
	});
	
	_canvas.addEventListener("Fire_MouseDown", function(e){
		var strPosition = Module.GetClickPosition();
		//console.log(strPosition);
		var strArray = strPosition.split('_');

		var pMap = Module.getMap();
		if(e.nButton==1)
		{
			pMap.addHeatMap(new Module.JSVector3D(parseFloat(strArray[0]), parseFloat(strArray[1]), parseFloat(strArray[2])));
		}
		else if(e.nButton==2)
		{
			pMap.addHeatMap3D(new Module.JSVector2D(parseFloat(strArray[0]), parseFloat(strArray[1])));
		}
	});
};

function removeAll()
{
	GLOBAL.statistic.removeAll();
	GLOBAL.totalArea = false;
	GLOBAL.selectindex = [];
}

// **ì¢Œí‘œ ë³€í™˜ í•¨ìˆ˜**
function convertToWGS84(x, y) {
	proj4.defs("EPSG:2097", "+proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=500000 +ellps=bassel +units=m +no_defs +towgs84=-115.80,474.99,674.11,1.16,-2.31,-1.63,6.43");
    return proj4("EPSG:2097", "EPSG:4326", [x, y]); // ê²°ê³¼: [ê²½ë„, ìœ„ë„]
}

function parseCSVLine(line) {
    const result = [];
    let current = "";
    let insideQuotes = false;

    for (let i = 0; i < line.length; i++) {
        const char = line[i];

        if (char === '"' && (i === 0 || line[i - 1] !== "\\")) {
            insideQuotes = !insideQuotes;
        } else if (char === "," && !insideQuotes) {
            result.push(current.trim() || null); // ë¹ˆ ê°’ì´ë©´ null ì €ì¥
            current = "";
        } else {
            current += char;
        }
    }
    result.push(current.trim()); // ë§ˆì§€ë§‰ ê°’ ì¶”ê°€
    return result;
}

async function parseLargeCSV(_type) {
	if(_type > 2) return;

	GLOBAL.positions = [];
	GLOBAL.values = [];

	var nStart = new Date().getTime();

	var response;
	if(_type == 0) response = await fetch("./csv/fulldata_07_24_04_P_ì¼ë°˜ìŒì‹ì .csv");	// 100ë§Œê°œ
	else if(_type == 1) response = await fetch("./csv/ì†Œë°©ì²­_ì†Œë°©ìš©ìˆ˜ì‹œì„¤_20240207.csv");	// 20ë§Œê°œ;
	else if(_type == 2) response = await fetch("./csv/fulldata_01_01_06_P_ì•½êµ­.csv");	// 6ë§Œê°œ;

	const contentLength = response.headers.get("Content-Length"); // ì „ì²´ íŒŒì¼ í¬ê¸° (ë°”ì´íŠ¸ ë‹¨ìœ„)
    const totalSize = contentLength ? parseInt(contentLength, 10) : null;

    const reader = response.body.getReader();
    const decoder = new TextDecoder("euc-kr"); // euc-kr ì¸ì½”ë”© ì§€ì •
    let { value: chunk, done } = await reader.read();
    let buffer = "";
	let loadedSize = 0; // í˜„ì¬ê¹Œì§€ ë¡œë“œëœ ë°”ì´íŠ¸ ìˆ˜
    let firstLine = true;
    let headers = [];

	let xIndex, yIndex, sizeIndex;
    while (!done) {
		loadedSize += chunk.length;
        buffer += decoder.decode(chunk, { stream: true });
        let lines = buffer.split("\n");

        buffer = lines.pop(); // ë§ˆì§€ë§‰ ì¤„ì€ ì•„ì§ ì™„ì„±ë˜ì§€ ì•Šì•˜ì„ ìˆ˜ë„ ìˆìœ¼ë‹ˆ ë³´ë¥˜

        for (let line of lines) {
			let columns = parseCSVLine(line); // ì •ê·œì‹ ê¸°ë°˜ CSV íŒŒì‹±
            if (firstLine) {
                headers = columns.map(col => col.replace(/^\uFEFF/, "").trim()); // BOM ì œê±° í›„ ì €ì¥
                firstLine = false;
            } else {
				if(_type == 0) {
					xIndex = headers.findIndex(h => h.includes("ì¢Œí‘œì •ë³´x"));	// 26
					yIndex = headers.findIndex(h => h.includes("ì¢Œí‘œì •ë³´y"));	// 27
					sizeIndex = headers.findIndex(h => h.includes("ì‹œì„¤ì´ê·œëª¨"));	// 43
				}
				else if(_type == 1) {
					xIndex = headers.findIndex(h => h.includes("ê²½ë„"));	// 8
					yIndex = headers.findIndex(h => h.includes("ìœ„ë„"));	// 7
					sizeIndex = headers.findIndex(h => h.includes("ì„¤ì¹˜ì—°ë„"));	// 12
				}
				else if(_type == 2) {
					xIndex = headers.findIndex(h => h.includes("ì¢Œí‘œì •ë³´x"));	// 26
					yIndex = headers.findIndex(h => h.includes("ì¢Œí‘œì •ë³´y"));	// 27
					sizeIndex = headers.findIndex(h => h.includes("ì•½êµ­ì˜ì—…ë©´ì "));	// 28
				}
				let x = columns[xIndex] ? parseFloat(columns[xIndex]) : null;
                let y = columns[yIndex] ? parseFloat(columns[yIndex]) : null;
                let size = columns[sizeIndex] ? columns[sizeIndex] : null;

                if (x !== null && y !== null) {
					if(_type == 0 || _type == 2) {
						let [lon, lat] = convertToWGS84(x, y); // EPSG:5174 â†’ WGS84 ë³€í™˜
                    	GLOBAL.positions.push([lon, lat, 100]); // ë³€í™˜ëœ ê²½ìœ„ë„ ì¢Œí‘œ ì €ì¥
					}

					else if(_type == 1) GLOBAL.positions.push([x, y, 100]); // ë³€í™˜ëœ ê²½ìœ„ë„ ì¢Œí‘œ ì €ì¥
                }
                if (size !== null) {
					if(size <= 0) size = 1;
					if(size < 10) size = size * 100000;
					if(size < 100) size = size * 10000;
					if(size < 1000) size = size * 1000;
					if(size < 10000) size = size * 100;
					if(size < 100000) size = size * 10;
                    GLOBAL.values.push(size);
                }
            }
        }
		// í”„ë¡œê·¸ë ˆìŠ¤ ì—…ë°ì´íŠ¸
		let percent = ((loadedSize / totalSize) * 100).toFixed(2);
        //console.log(`ì§„í–‰ë¥ : ${percent}%`);

		if(_type == 0) document.getElementById('prograss_3').innerText = percent + "%";
		else if(_type == 1) document.getElementById('prograss_2').innerText = percent + "%";
		else if(_type == 2) document.getElementById('prograss_1').innerText = percent + "%";

        ({ value: chunk, done } = await reader.read());
    }
	var nEnd = new Date().getTime();
	const time = nEnd - nStart;

	if(_type == 0) document.getElementById('timer_3').innerText = time/1000 + "ì´ˆ";
	else if(_type == 1) document.getElementById('timer_2').innerText = time/1000 + "ì´ˆ";
	else if(_type == 2) document.getElementById('timer_1').innerText = time/1000 + "ì´ˆ";
	
    //console.log("positions:", GLOBAL.positions);
	//console.log("values:", GLOBAL.values);
	//alert("csv parsing ì™„ë£Œ");

	// GLOBAL.positions ì˜ì—­ ë¶„í• 
	if(_type == 0) divideIntoTiles();

}

/////////////////////////////////////////// ëŒ€ìš©ëŸ‰ ë°ì´í„° ///////////////////////////////////////////
// ìµœì†Œ/ìµœëŒ€ ê²½ë„(lon)ì™€ ìœ„ë„(lat) ì°¾ê¸°
function getBounds(positions) {
    let minLon = Infinity, maxLon = -Infinity;
    let minLat = Infinity, maxLat = -Infinity;

    positions.forEach(([lon, lat]) => {
        if (lon < minLon) minLon = lon;
        if (lon > maxLon) maxLon = lon;
        if (lat < minLat) minLat = lat;
        if (lat > maxLat) maxLat = lat;
    });

    return { minLon, maxLon, minLat, maxLat };
}

// ì¢Œí‘œë¥¼ 10ê°œì˜ êµ¬ì—­ìœ¼ë¡œ ë¶„í• í•˜ì—¬ ì •ë¦¬
function divideIntoTiles() {
    const { minLon, maxLon, minLat, maxLat } = getBounds(GLOBAL.positions);
    
    let lonStep = (maxLon - minLon) / 5;  // ê²½ë„ë¥¼ 5ê°œ êµ¬ì—­ìœ¼ë¡œ ë‚˜ëˆ”
    let latStep = (maxLat - minLat) / 2;  // ìœ„ë„ë¥¼ 2ê°œ êµ¬ì—­ìœ¼ë¡œ ë‚˜ëˆ”

    GLOBAL.positions.forEach(([lon, lat], index) => {
        let value = GLOBAL.values[index] || null; // ê°’ì´ ì—†ì„ ê²½ìš° null ì €ì¥

        // ì¢Œí‘œê°€ ì†í•œ íƒ€ì¼ ì¸ë±ìŠ¤ ê³„ì‚° (0~9)
        let lonIndex = Math.min(4, Math.floor((lon - minLon) / lonStep));
        let latIndex = Math.min(1, Math.floor((lat - minLat) / latStep));
        let tileIndex = latIndex * 5 + lonIndex; // 0~9 ë²”ìœ„

        // í•´ë‹¹ íƒ€ì¼ì— ì¢Œí‘œì™€ ê°’ ë¶„ë¦¬ ì €ì¥
        GLOBAL.tilePositions[tileIndex].positions.push([lon, lat, 200]); // ì¢Œí‘œë§Œ ì €ì¥
        GLOBAL.tilePositions[tileIndex].values.push(value); // ê°’ë§Œ ì €ì¥
    });

    console.log(GLOBAL.tilePositions);

	document.getElementById("index_1").value = GLOBAL.tilePositions[5].positions.length + "ê°œ"; 
	document.getElementById("index_2").value = GLOBAL.tilePositions[6].positions.length + "ê°œ"; 
	document.getElementById("index_3").value = GLOBAL.tilePositions[7].positions.length + "ê°œ"; 
	document.getElementById("index_4").value = GLOBAL.tilePositions[8].positions.length + "ê°œ"; 
	document.getElementById("index_5").value = GLOBAL.tilePositions[9].positions.length + "ê°œ"; 
	document.getElementById("index_6").value = GLOBAL.tilePositions[0].positions.length + "ê°œ"; 
	document.getElementById("index_7").value = GLOBAL.tilePositions[1].positions.length + "ê°œ"; 
	document.getElementById("index_8").value = GLOBAL.tilePositions[2].positions.length + "ê°œ"; 
	document.getElementById("index_9").value = GLOBAL.tilePositions[3].positions.length + "ê°œ"; 
	document.getElementById("index_10").value = GLOBAL.tilePositions[4].positions.length + "ê°œ"; 
}

function loadTilingPositionData(_area)
{
	if(_area == 100) {
		GLOBAL.totalArea = true;
	}
	if(GLOBAL.strShape=='symbol') {
		loadLargeSymbol("./3ds/tree.3ds");
		return;
	}

	if(_area == 100) {
		GLOBAL.selectindex = [];
		GLOBAL.statistic.removeAll();

		console.log(GLOBAL.strShape);

		var dataInfo = {
		objects : [
			{	
				key : "Test",
				dataType : "position",
				type : "instanced",
				shape : strShape,
				points : GLOBAL.positions,
				value : GLOBAL.values,
				weight : [1, 1, 1],
				},
			]
		}
		var statistic = Module.getStatistic();
		const json = JSON.stringify(dataInfo);
		statistic.createByJSON(json); 
		
	}
	else {
		if(GLOBAL.totalArea) return;
		
		GLOBAL.totalArea = false;
		GLOBAL.selectindex.push(_area);
		var dataInfo = {
			key : "Test",
			type : "position",
			shape : GLOBAL.strShape,
			position : GLOBAL.tilePositions[_area].positions,
			value : GLOBAL.tilePositions[_area].values,
			weight : [100.0, 100.0, 100.0],
		}
		
		
		GLOBAL.statistic.create(dataInfo);
	}
}

function loadIconType(_strFile)
{
	fetch(_strFile)
	  .then(res => res.arrayBuffer())
	  .then(buffer => {
		let binary = '';
		const bytes = new Uint8Array(buffer);
		for (let b of bytes) binary += String.fromCharCode(b);
		const base64 = btoa(binary);
		console.log(base64);
		
		var dataInfo = {
		objects : [
			{	
				key : "Test",
				dataType : "position",
				type : "instanced",
				shape : "icon",
				points : GLOBAL.positions,
				value : GLOBAL.values,
				weight : [1, 1, 1],
				image :  {
					base64 : base64,
					},
				},
			]
		}
		
		var statistic = Module.getStatistic();
		const json = JSON.stringify(dataInfo);
		statistic.createByJSON(json); 
	});
}

// function changeShapeType(_nIndex)
// {
// 	if(_nIndex == 0) GLOBAL.strShape = "vertical_line";
// 	else if(_nIndex == 1) GLOBAL.strShape = "cylinder";
// 	else if(_nIndex == 2) GLOBAL.strShape = "circle";
// 	else if(_nIndex == 3) GLOBAL.strShape = "sphere";
// 	else if(_nIndex == 4) {
// 		GLOBAL.strShape = "symbol";
// 		loadLargeSymbol("./3ds/tree.3ds");
// 		return;
// 	}
// 	else if(_nIndex == 6) {
// 		GLOBAL.strShape = "icon";
// 		loadIconType("./images/config_users.png");
// 		return;
// 	}

// 	var dataInfo = {
// 		objects : [
// 			{	
// 				key : "Test",
// 				dataType : "position",
// 				type : "instanced",
// 				shape : "symbol",
// 				points : GLOBAL.positions,
// 				value : GLOBAL.values,
// 				weight : [0.1, 0.1, 0.1],
// 				},
// 			]
// 		}
	
// 	const json = JSON.stringify(dataInfo);
// 	console.log(json);
// 	GLOBAL.statistic.createByJSON(json);
// }

function loadLargeSymbol(_strFile)
{
	fetch(_strFile)
	  .then(res => res.arrayBuffer())
	  .then(buffer => {
		let binary = '';
		const bytes = new Uint8Array(buffer);
		for (let b of bytes) binary += String.fromCharCode(b);
		const base64 = btoa(binary);
		console.log(base64);
		
		var dataInfo = {
		objects : [
			{	
				key : "Test",
				dataType : "position",
				type : "instanced",
				shape : "symbol",
				points : GLOBAL.positions,
				value : GLOBAL.values,
				weight : [1, 1, 1],
				symbol : { 
					data : base64, 
					type : "3ds",
					},
				},
			]
		}
		
		var statistic = Module.getStatistic();
		const json = JSON.stringify(dataInfo);
		statistic.createByJSON(json); 
	});
}

function clustering(_type)
{
	GLOBAL.statistic.removeAll();
	var nStart = new Date().getTime();

	// Kd-tree ì¸ë±ìŠ¤ë¥¼ ìƒì„± (ìœ„ë„, ê²½ë„ ë°ì´í„°ë¥¼ ì‚¬ìš©)
    const index = new KDBush(GLOBAL.positions, p => p[0], p => p[1]);

	let visited = new Set();

	for (let i = 0; i < GLOBAL.positions.length; i++) {
		if (visited.has(i)) continue;

		let clusterPoints = [];
		let clusterValues = [];
		let sumLon = 0, sumLat = 0, sumValues = 0;

		let [lon1, lat1] = GLOBAL.positions[i];

		// ğŸš€ Kd-treeë¥¼ ì‚¬ìš©í•˜ì—¬ 1km ë°˜ê²½ ë‚´ ì ë“¤ì„ ë¹ ë¥´ê²Œ ê²€ìƒ‰
		let nearby = index.within(lon1, lat1, 1);

		for (let j of nearby) {
			if (!visited.has(j)) {
				let [lon2, lat2] = GLOBAL.positions[j];

				if (getDistance(lon1, lat1, lon2, lat2) <= 1) { // 1km ì´ë‚´
					clusterPoints.push(GLOBAL.positions[j]);
					clusterValues.push(GLOBAL.values[j]);
					sumLon += lon2;
					sumLat += lat2;
					sumValues += GLOBAL.values[j];
					visited.add(j);
				}
			}
		}

		let clusterSize = clusterPoints.length;
		if (clusterSize > 0) {
			let centroidLon = sumLon / clusterSize;
			let centroidLat = sumLat / clusterSize;
			//let averageValue = sumValues / clusterSize;
			GLOBAL.clustersPoints.push([centroidLon, centroidLat, 200]);
			GLOBAL.clustersValues.push(GLOBAL.values[i]);
		}

		// ì§„í–‰ë¥  ê³„ì‚° (í˜„ì¬ ì¸ë±ìŠ¤ë¥¼ ì „ì²´ ê¸¸ì´ë¡œ ë‚˜ëˆ„ê¸°)
        let percent = Math.floor(((i + 1) / GLOBAL.positions.length) * 100);

		if(_type == 1) document.getElementById('cluster_prograss_1').innerText = percent + "%";
		else if(_type == 2) document.getElementById('cluster_prograss_2').innerText = percent + "%";
		else if(_type == 3) document.getElementById('cluster_prograss_3').innerText = percent + "%";
	}

	var nEnd = new Date().getTime();
	const time = nEnd - nStart;

	if(_type == 1) {
		document.getElementById('cluster_timer_1').innerText = time + "ì´ˆ";
		document.getElementById('cluster_prograss_1').innerText = "100%";
		document.getElementById('clustercount_1').innerText = GLOBAL.clustersPoints.length + "ê°œ";
	} else if(_type == 2) {
		document.getElementById('cluster_timer_2').innerText = time + "ì´ˆ";
		document.getElementById('cluster_prograss_2').innerText = "100%";
		document.getElementById('clustercount_2').innerText = GLOBAL.clustersPoints.length + "ê°œ";
	} else if(_type == 3) {
		document.getElementById('cluster_timer_3').innerText = time + "ì´ˆ";
		document.getElementById('cluster_prograss_3').innerText = "100%";
		document.getElementById('clustercount_3').innerText = GLOBAL.clustersPoints.length + "ê°œ";
	}
}

// 1km ì´ë‚´ì¸ì§€ í™•ì¸í•˜ëŠ” ê±°ë¦¬ ê³„ì‚° (Haversine ê³µì‹ ì‚¬ìš©)
function getDistance(lon1, lat1, lon2, lat2) {
    const R = 6371; // ì§€êµ¬ ë°˜ì§€ë¦„ (km)
    const toRad = deg => deg * (Math.PI / 180);
    
    let dLat = toRad(lat2 - lat1);
    let dLon = toRad(lon2 - lon1);

    let a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);

    let c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c; // ê±°ë¦¬ (km)
}

function removeCruster()
{
	GLOBAL.statistic.removeAll();
	GLOBAL.clustersPoints = [];
	GLOBAL.clustersValues = [];
}
/////////////////////////////////////////// ëŒ€ìš©ëŸ‰ ë°ì´í„° ///////////////////////////////////////////

/////////////////////////////////////////// ì¼ë°˜ ë°ì´í„° ///////////////////////////////////////////
function loadPositionData(shapeType)
{

	GLOBAL.statistic.removeAll();
	GLOBAL.totalArea = false;

	if (shapeType === 'symbol') {
		loadSymbol('./3ds/tree.3ds');
		return;
	  }

	  if (shapeType === 'icon') {
		loadIconType('./markers/config_users.png');
		return;
	  }
	// var strShape;
	// if(_nIndex == 0) strShape = "vertical_line";
	// else if(_nIndex == 1) strShape = "cylinder";
	// else if(_nIndex == 2) strShape = "circle";
	// else if(_nIndex == 3) strShape = "sphere";
	// else if(_nIndex == 4) {
	// 	loadSymbol("./3ds/tree.3ds");
	// 	return;
	// }
	// else if(_nIndex == 6) {
	// 	loadIconType("./images/config_users.png");
	// 	return;
	// }

	//console.log(GLOBAL.positions);
	//console.log(GLOBAL.values);

	const strShape = shapeType || "sphere"; // âœ… ì—¬ê¸°ì„œ ì œëŒ€ë¡œ ë°›ëŠ” ê²ƒ
	console.log("ğŸ“ shapeTypeìœ¼ë¡œ ê°€ì‹œí™”:", strShape);

	var dataInfo = {
		objects : [
			{	
				key : "Test",
				dataType : "position",
				type : "instanced",
				shape: strShape,
				points : GLOBAL.positions,
				value : GLOBAL.values,
				weight : [1, 1, 1],
				},
			]
		}
	
	const json = JSON.stringify(dataInfo);
	console.log(json);
	GLOBAL.statistic.createByJSON(json);
}

function loadSymbol(_strFile)
{
	GLOBAL.statistic.removeAll();

	fetch(_strFile)
	  .then(res => res.arrayBuffer())
	  .then(buffer => {
		let binary = '';
		const bytes = new Uint8Array(buffer);
		for (let b of bytes) binary += String.fromCharCode(b);
		const base64 = btoa(binary);
		console.log(base64);
		
		var dataInfo = {
		objects : [
			{	
				key : "Test",
				dataType : "position",
				type : "instanced",
				shape : "symbol",
				points : GLOBAL.positions,
				value : GLOBAL.values,
				weight : [1, 1, 1],
				symbol : { 
					data : base64, 
					type : "3ds",
					},
				},
			]
		}
		
		var statistic = Module.getStatistic();
		const json = JSON.stringify(dataInfo);
		statistic.createByJSON(json); 
	});

}

/////////////////////////////////////////// ì¼ë°˜ ë°ì´í„° ///////////////////////////////////////////